# vim: set ft=python :
# vim: set expandtab :

import math
import time
import cProfile

import Draft
import FreeCADGui
import OpenSCADUtils
import TechDraw
import Part
import DraftGeomUtils
import draftgeoutils
import importDXF
from FreeCAD import Units

class Slice_Base(list):
  intersection_count: int
  plane = App.Vector(0, 0, 0)
  lowest_point = 0
  section_positions = []

  def __init__(self, doc, hull_body, intersection_count = None, section_positions = []):
    print(f"Calculating {self.__class__.__name__}")
    self.doc = doc
    self.hull_body = hull_body
    self.intersection_count = intersection_count
    self.section_positions = section_positions
    bound_box = self.hull_body.Shape.BoundBox
    self.lowest_point = bound_box.ZMin

    self.slice()

  def _setup_section_positions(self):
    bound_box = self.hull_body.Shape.BoundBox

    if self.plane.x:
      self.slice_start = bound_box.XMin
      slice_range = bound_box.XLength
    elif self.plane.y:
      self.slice_start = bound_box.YMin
      slice_range = bound_box.YLength
    elif self.plane.z:
      self.slice_start = bound_box.ZMin
      slice_range = bound_box.ZLength
    self.slice_width = slice_range / (self.intersection_count + 1)

    self.section_positions = [
          self.slice_start + (i * self.slice_width) + 0.1
          for i in range(self.intersection_count + 1)
        ]

  def slice(self):
    if not self.section_positions:
      self._setup_section_positions()

    slices = self.hull_body.Shape.slices(self.plane, self.section_positions)
    print(f"{len(slices.Wires)} sections drawn for the {self.plane} axis")
    for slice in slices.Wires:
      self += self.slice_to_edges(slice)

  def slice_to_edges(self, slice):
    all_edges = []
    for edge in slice.Edges:
      candiate = self.filter_edge(edge)
      if candiate:
        all_edges.append(candiate)

    wires = []
    for wire in Part.sortEdges(all_edges):
      wires.append(Part.Wire(wire))
    return wires

  @classmethod
  def filter_edge(cls, edge):
    start_point = edge.firstVertex()
    end_point = edge.lastVertex()

    if start_point.X < -0.0001 or end_point.X < -0.0001:
      return None

    return edge

  def longest_element(self):
    longest = None
    for wire in self:
      if longest is None or wire.Length > longest.Length:
        longest = wire

    return longest


class Slice_CrossSection(Slice_Base):
  plane = App.Vector(0, 1, 0)

  def _setup_section_positions(self):
    bound_box = self.hull_body.Shape.BoundBox

    if self.section_positions:
      pass
    elif self.intersection_count:
      slice_range = bound_box.YLength
      slice_width = slice_range / (self.intersection_count + 1)
      slice_end = bound_box.YMax - slice_width / 4

      self.slice_start = bound_box.YMin + slice_width / 4 + 1
      self.slice_width = abs(self.slice_start - slice_end) / (self.intersection_count - 1)

      self.section_positions = [
            self.slice_start + (i * self.slice_width) + 0.1
            for i in range(self.intersection_count + 1)
          ]
    else:
      dimensions = doc.getObjectsByLabel("dimensions")[0]
      index = 0
      self.section_positions = []
      while True:
        rib_pos_label = f"rib_positions_{index}"
        try:
          rib_position = dimensions.get(rib_pos_label)
        except ValueError:
          break
        self.section_positions.append(rib_position)
        index += 1


class Slice_Waterline(Slice_Base):
  plane = App.Vector(0, 0, 1)


class Slice_Profile(Slice_Base):
  plane = App.Vector(1, 0, 0)


class Slice_Diagonals(Slice_Base):
  plane = App.Vector(1, 0, 1)

  def __init__(self, doc, hull_body, ribs: Slice_CrossSection, intersection_count = None, section_positions = []):
    self.ribs = ribs
    super().__init__(doc, hull_body, intersection_count, section_positions)

  def _iterate_positions(self):
    dimensions = doc.getObjectsByLabel("dimensions")[0]

    if not self.section_positions and not self.intersection_count:
      index = 0
      self.section_positions = []
      while True:
        angle_label = f"diagonal_angles_{index}"
        height_label = f"diagonal_heights_{index}"
        try:
          diagonal_angle = dimensions.get(angle_label)
          diagonal_height = dimensions.get(height_label)
        except ValueError:
          break
        self.section_positions.append((diagonal_angle, diagonal_height))
        index += 1

    if self.section_positions:
      for angle, dist in self.section_positions:
        yield angle, dist
    else:
      assert self.intersection_count is not None
      angle = 90
      slice_angle_step = angle / self.intersection_count / 1.8

      for _, position in self.iterate_longest_rib():
        angle -= slice_angle_step
        if angle <= 0:
          break
        dist = position.z - position.x / math.tan(math.radians(-angle))
        yield angle, dist

  def slice(self):
    """
    The Diagonals don't follow the same pattern as the other perspectives.
    The plane changes angle with each slice.
    """
    for angle, dist in self._iterate_positions():
      print(f"Calculating diagonal. angle: {round(angle, 2)}  height: {round(dist, 2)}")

      plane = App.Vector(math.cos(math.radians(angle)), 0, math.sin(math.radians(angle)))
      slices = self.hull_body.Shape.slice(plane, math.sin(math.radians(angle)) * dist)
      if not slices:
        continue

      for slice in slices:
        wires = self.slice_to_edges(slice)
        if len(wires) > 1:
          longest = None
          for wire in wires:
            if longest is None or wire.Length > longest.Length:
              longest = wire
          wires = [longest]
        self += wires

  def iterate_longest_rib(self):
    rib = self.ribs.longest_element()
    #Part.show(rib, "rib")
    part_length = rib.Length / self.intersection_count
    rib_parts = rib.discretize(Distance = part_length)
    distance = 0
    for index, position in enumerate(rib_parts):
      yield (rib, position)
      distance += part_length


  @classmethod
  def filter_edge(cls, edge):
    # Filter edges ending when crossing over to other side of hull.
    start_point = edge.firstVertex()
    end_point = edge.lastVertex()
    if start_point.X < 0.0001 and end_point.X < 0.0001:
      return None

    # Filter intersections with deck.
    sketch = doc.getObjectsByLabel('profile_deck')[0]
    for sketch_edge in sketch.Shape.Edges:
      for point in edge.Vertexes:
        point = point.Point
        point.x = 0
        point = Part.Vertex(point)
        common = point.common([sketch_edge])
        if common.Vertexes:
          return None

    #Part.show(edge)
    return edge


class View_Wireframe_Base:
  """
  Base class to display wireframe of hull.
  """
  name: str = "base_class"

  def __init__(self, parent_name: str, doc, hull_body, data: Slice_Base):
    self.name = f"{parent_name}__{self.plan_name}"
    self.wireframe_name = f"{parent_name}__{self.wireframe_name}"
    self.doc = doc
    self.hull_body = hull_body
    self.data = data

    if not self._calculate():
      remove_group(doc, self.wireframe_name)
      return

    self.create_blank_sketch()

    for slice_index, slice in enumerate(self.data):
      self.parse_slice(slice, slice_index)

    for shape in self.wireframe.OutList:
      FreeCADGui.getDocument(self.doc.Name).getObject(shape.Name).LineColor = self.colour
      FreeCADGui.getDocument(self.doc.Name).getObject(shape.Name).PointColor = self.colour

    self._cleanup()

  def _cleanup(self):
    Gui.Selection.clearSelection()
    addSelection(self.doc, self.wireframe_name)
    dimensions = doc.getObjectsByLabel("dimensions")[0]
    if int(dimensions.get("show_wireframe")):
      Gui.runCommand('Std_ShowSelection', 0)
    else:
      Gui.runCommand('Std_HideSelection', 0)

  def _calculate(self):
    dimensions = doc.getObjectsByLabel("dimensions")[0]
    return dimensions.get("calculate_wireframe")

  def create_blank_sketch(self):
    self.wireframe = create_group(self.doc, self.wireframe_name)

  def parse_slice(self, slice, slice_index):
    if not slice:
      return
    new_object = Part.show(slice)
    self.wireframe.addObjects([new_object])


class View_Wireframe_Body(View_Wireframe_Base):
  plan_name = "plan_body"
  wireframe_name = "wireframe_body"

  plan_offset = App.Vector(+2000.0, 0.0, 0.0)
  colour_fore = (255, 0, 0)
  colour_aft = (255, 255, 0)
  colour = (255, 0, 0)

  def __init__(self, parent_name: str, doc, hull_body, data: Slice_Base):
    super().__init__(parent_name, doc, hull_body, data)

    for shape in self.wireframe_fore.OutList:
      FreeCADGui.getDocument(self.doc.Name).getObject(shape.Name).LineColor = self.colour_fore
      FreeCADGui.getDocument(self.doc.Name).getObject(shape.Name).PointColor = self.colour_fore

    for shape in self.wireframe_aft.OutList:
      FreeCADGui.getDocument(self.doc.Name).getObject(shape.Name).LineColor = self.colour_aft
      FreeCADGui.getDocument(self.doc.Name).getObject(shape.Name).PointColor = self.colour_aft

    self._later_cleanup()

  def _cleanup(self):
    return

  def _later_cleanup(self):
    Gui.Selection.clearSelection()
    addSelection(self.doc, self.wireframe_fore.Name)
    addSelection(self.doc, self.wireframe_aft.Name)
    dimensions = doc.getObjectsByLabel("dimensions")[0]
    if int(dimensions.get("show_wireframe")):
      Gui.runCommand('Std_ShowSelection', 0)
    else:
      Gui.runCommand('Std_HideSelection', 0)

  def _calculate(self):
    """ Always calculate this sub class. """
    return True

  def create_blank_sketch(self):
    self.wireframe_fore = create_group(self.doc, f"{self.wireframe_name}_fore")
    self.wireframe_aft = create_group(self.doc, f"{self.wireframe_name}_aft")
    self.wireframe = self.wireframe_fore

  def parse_slice(self, slice, slice_index):
    if slice_index > len(self.data) / 2:
      self.wireframe = self.wireframe_fore
      self.colour = self.colour_fore
    else:
      self.wireframe = self.wireframe_aft
      self.colour = self.colour_aft

    super().parse_slice(slice, slice_index)


class View_Wireframe_Waterline(View_Wireframe_Base):
  plan_name = "plan_waterline"
  wireframe_name = "wireframe_waterline"
  plan_offset = App.Vector(+4000.0, 0.0, 0.0)
  colour = (0, 255, 0)


class View_Wireframe_Profile(View_Wireframe_Base):
  plan_name = "plan_profile"
  wireframe_name = "wireframe_profile"
  plan_offset = App.Vector(+6000.0, 0.0, 0.0)
  colour = (0, 0, 255)


class View_Wireframe_Diagonals(View_Wireframe_Base):
  plan_name = "plan_diagonal"
  wireframe_name = "wireframe_diagonal"
  plan_offset = App.Vector(+8000.0, 0.0, 0.0)
  colour = (200, 200, 200)


class Plans:
  def __init__(self, doc, parent_name: str, lowest_point: float):
    self.doc = doc
    self.lowest_point = lowest_point

    plan_profile_name = f"{parent_name}__plan_profile"
    plan_body_name = f"{parent_name}__plan_body"
    plan_waterline_name = f"{parent_name}__plan_waterline"

    dimensions = doc.getObjectsByLabel("dimensions")[0]
    if not dimensions.get("calculate_plans"):
      remove_group(self.doc, plan_profile_name)
      remove_group(self.doc, plan_body_name)
      remove_group(self.doc, plan_waterline_name)
      return

    group_profile = create_group(doc, plan_profile_name)
    group_body = create_group(doc, plan_body_name)
    group_waterline = create_group(doc, plan_waterline_name)

    offset_plan_profile = 2000
    offset_plan_body = 3000
    offset_plan_waterline = 4500

    label = f"{parent_name}__wireframe_profile"
    if has_object_by_label(doc, label):
      for shapes in self.doc.getObjectsByLabel(label):
        for shape in shapes.OutList:
          self.draw_line(shape.Shape, App.Vector(1, 0, 0), offset_plan_profile, group_profile, True, False)
          self.draw_line(shape.Shape, App.Vector(0, 1, 0), offset_plan_body, group_body, False, False)
          self.draw_line(shape.Shape, App.Vector(0, 1, 0), offset_plan_body, group_body, False, True)
          self.draw_line(shape.Shape, App.Vector(0, 0, 1), offset_plan_waterline, group_waterline, False, False)
          self.draw_line(shape.Shape, App.Vector(0, 0, 1), offset_plan_waterline, group_waterline, False, True)

    label = f"{parent_name}__wireframe_body_fore"
    if has_object_by_label(doc, label):
      for shapes in self.doc.getObjectsByLabel(label):
        for shape in shapes.OutList:
          self.draw_line(shape.Shape, App.Vector(1, 0, 0), offset_plan_profile, group_profile, False, False)
          self.draw_line(shape.Shape, App.Vector(0, 1, 0), offset_plan_body, group_body, True, False)
          self.draw_line(shape.Shape, App.Vector(0, 0, 1), offset_plan_waterline, group_waterline, False, False)
          self.draw_line(shape.Shape, App.Vector(0, 0, 1), offset_plan_waterline, group_waterline, False, True)

    label = f"{parent_name}__wireframe_body_aft"
    if has_object_by_label(doc, label):
      for shapes in self.doc.getObjectsByLabel(label):
        for shape in shapes.OutList:
          self.draw_line(shape.Shape, App.Vector(1, 0, 0), offset_plan_profile, group_profile, False, False)
          self.draw_line(shape.Shape, App.Vector(0, 1, 0), offset_plan_body, group_body, True, True)
          self.draw_line(shape.Shape, App.Vector(0, 0, 1), offset_plan_waterline, group_waterline, False, False)
          self.draw_line(shape.Shape, App.Vector(0, 0, 1), offset_plan_waterline, group_waterline, False, True)

    label = f"{parent_name}__wireframe_waterline"
    if has_object_by_label(doc, label):
      for shapes in self.doc.getObjectsByLabel(label):
        for shape in shapes.OutList:
          self.draw_line(shape.Shape, App.Vector(1, 0, 0), offset_plan_profile, group_profile, False, False)
          self.draw_line(shape.Shape, App.Vector(0, 1, 0), offset_plan_body, group_body, False, False)
          self.draw_line(shape.Shape, App.Vector(0, 1, 0), offset_plan_body, group_body, False, True)
          self.draw_line(shape.Shape, App.Vector(0, 0, 1), offset_plan_waterline, group_waterline, True, False)

    label = f"{parent_name}__wireframe_diagonal"
    if has_object_by_label(doc, label):
      for shapes in self.doc.getObjectsByLabel(label):
        for shape in shapes.OutList:
          self.draw_line(shape.Shape, App.Vector(0, 0, 1), offset_plan_waterline, group_waterline, True, True)
          self.draw_line(shape.Shape, App.Vector(0, 1, 0), offset_plan_body, group_body, False, False)
          self.draw_line(shape.Shape, App.Vector(0, 1, 0), offset_plan_body, group_body, False, True)

    self.extra(group_profile, offset_plan_profile)

    Gui.Selection.clearSelection()
    addSelection(self.doc, f"{parent_name}__plan_profile")
    addSelection(self.doc, f"{parent_name}__plan_body")
    addSelection(self.doc, f"{parent_name}__plan_waterline")
    addSelection(self.doc, f"{parent_name}__plan_diagonal")
    dimensions = doc.getObjectsByLabel("dimensions")[0]
    if int(dimensions.get("show_plans")):
      Gui.runCommand('Std_ShowSelection', 0)
    else:
      Gui.runCommand('Std_HideSelection', 0)

  def draw_line(self, shape, direction, x_pos, group, foreground: bool, mirror: bool):
    outline, _, _, _ = TechDraw.project(shape, direction)
    new = Part.show(outline, "outline")

    if direction == App.Vector(1, 0, 0):
      new.Placement = App.Placement(
          App.Vector(x_pos - self.lowest_point, 0, self.lowest_point),
          App.Vector(1, 0, 0), 180)

    if mirror:
      if direction == App.Vector(0, 1, 0):
        new.Placement = App.Placement(
            App.Vector(x_pos - self.lowest_point, 0, self.lowest_point),
            App.Vector(1, 0, 0), 180)
      elif direction == App.Vector(0, 0, 1):
        new.Placement = App.Placement(
            App.Vector(x_pos, 0, self.lowest_point),
            App.Vector(0, 1, 0), 180)
    else:
      if direction == App.Vector(0, 1, 0):
        new.Placement = App.Placement(
            App.Vector(x_pos - self.lowest_point, 0, self.lowest_point),
            App.Vector(1, 0, 0), 0)
      elif direction == App.Vector(0, 0, 1):
        new.Placement = App.Placement(
            App.Vector(x_pos, 0, self.lowest_point),
            App.Vector(0, 1, 0), 0)

    if foreground:
      FreeCADGui.getDocument(self.doc.Name).getObject(new.Name).LineWidth = 2
      FreeCADGui.getDocument(self.doc.Name).getObject(new.Name).PointSize = 2
    else:
      FreeCADGui.getDocument(self.doc.Name).getObject(new.Name).LineWidth = 1
      FreeCADGui.getDocument(self.doc.Name).getObject(new.Name).PointSize = 1

    group.addObjects([new])

  def extra(self, group, offset_plan_profile):
    sketches = [
        doc.getObjectsByLabel('dagger_board')[0],
        doc.getObjectsByLabel('rudder')[0],
        doc.getObjectsByLabel('skeg')[0],
        ]

    for sketch in sketches:
      direction = App.Vector(1, 0, 0)
      shape = sketch.Shape

      outline, _, _, _ = TechDraw.project(shape, direction)
      new = Part.show(outline, "outline")
      new.Placement = App.Placement(
          App.Vector(offset_plan_profile, 0, 0),
          direction, 180)

      group.addObjects([new])


class Components:
  stringers = []
  ribs = {}
  components_flat = {}
  components_bulk = {}

  def __init__(self, doc, parent_name: str, body, diagonals: Slice_Diagonals):
    self.doc = doc
    self.parent_name = parent_name
    self.group = create_group(doc, f"{parent_name}__components")
    self.hull = body
    self.diagonals = diagonals
    ribs_data = {}
    rib_diagonal_intersections = {}
    self.rib_groups = {}
    self.stringers_group = None

    self.draw_stringers()
    self.draw_gunwale()

    self.draw_stem()
    self.draw_stern()
    self.draw_keelson()

    label = f"{parent_name}__wireframe_body_fore"
    if has_object_by_label(doc, label):
      for shapes in self.doc.getObjectsByLabel(label):
        for shape in shapes.OutList:
          self.index_ribs(shape.Shape, ribs_data)

    label = f"{parent_name}__wireframe_body_aft"
    if has_object_by_label(doc, label):
      for shapes in self.doc.getObjectsByLabel(label):
        for shape in shapes.OutList:
          self.index_ribs(shape.Shape, ribs_data)

    for rib_index, y_pos in enumerate(sorted(ribs_data.keys(), key = lambda val: int(val))):
      self.draw_rib(doc, y_pos, rib_index, ribs_data[y_pos][0])

    self.mirror_sides()

    self.draw_deck()

  def index_ribs(self, shape, ribs_data):
    y_pos = str(round(shape.BoundBox.YMin))
    if y_pos not in ribs_data:
      ribs_data[y_pos] = []

    ribs_data[y_pos].append(shape)

  def diagonal_normals(self):
    for diagonal in self.diagonals:
      shape = Part.Shape([diagonal])
      yield (shape, self.diagonal_normal_at(shape, shape.Vertexes[0]))

  def draw_stringers(self):
    dimensions = doc.getObjectsByLabel("dimensions")[0]
    stringer_width = dimensions.get("stringer_width")
    stringer_depth = dimensions.get("stringer_depth")
    accurate_stringers = dimensions.get("accurate_stringers")
    self.stringers_deep = []

    hull = self.hull.copy()

    fatten = 1
    for d, normal in self.diagonal_normals():
      print(f"Drawing stringer. {normal}")

      if get_wire_curvature(d.Wires[0]) < 0:
        d.reverse()

      # Make stringer slightly bigger than it actually is so we don't hit boolean comparison
      # issues later due to faces being in the same place on identical planes.
      pattern = clean_wire2(d.copy())
      pattern.translate(normal.normalize() * ((stringer_width.Value + fatten) / 2))
      pattern = pattern.makeOffset2D(fatten / 2, openResult = True, fill = False)
      pattern = pattern.makeOffset2D((stringer_depth + Units.Quantity(f"{fatten}mm")), openResult = True, fill = True)
      stringer = pattern.extrude(normal.normalize() * (-stringer_width.Value - fatten))

      # This deeper version of the stringer cuts the full notch out of the rib.
      # Since the plane of each stringer's curve is at a different angle to the main
      # hull it would be hard to calculate the correct shape for each notch.
      # Instead, this stringer extends all the way out of the notch so we can do a boolean cut.
      pattern_deep = clean_wire2(d.copy())
      pattern_deep.translate(normal.normalize() * stringer_width / 2)
      pattern_deep = pattern_deep.makeOffset2D(-stringer_depth * 2, openResult = True, fill = False)
      pattern_deep = pattern_deep.makeOffset2D(stringer_depth * 3, openResult = True, fill = True)
      stringer_deep = pattern_deep.extrude(-normal.normalize() * stringer_width)

      if int(accurate_stringers):
        stringer_original = stringer.copy()
        # Since the main stringer's outer face is likely to be collinear with the hull's outer surface,
        # bugs when performing the boolean operation to shape the outer face of the stringer to match
        # the outer face of the hull.
        # Instead we do the boolean operation with a copy of the deeper stringer,
        # then a 2nd boolean operation between that and the proper stringer (that has the correct dimensions).
        stringer_hull = stringer_deep.copy().common(hull)

        # This knocks off the sharp corner of the stringer that protrudes through the hull surface.
        # In real life, we'll use a plane.
        stringer = stringer_hull.common(stringer)

        if stringer.BoundBox.XLength < 1e-4 or stringer.BoundBox.XLength > 1e10:
          print("WARN: Problem with stringer geometry.")
          # Fall back to raw (un-chamfered) shape.
          stringer = stringer_original

      self.stringers.append(stringer)
      self.stringers_deep.append(stringer_deep)
      #Part.show(stringer, "stringer")
      #Part.show(stringer_deep, "stringer_deep")

    # set up the group to store the displayed stringers in later.
    self.stringers_group = create_group(doc, f"stringers")
    self.group.addObjects([self.stringers_group])

  def draw_gunwale(self):
    profile_deck = doc.getObjectsByLabel('profile_deck')[0]
    plan_deck = doc.getObjectsByLabel('plan_deck')[0]
    dimensions = doc.getObjectsByLabel("dimensions")[0]
    stringer_width = dimensions.get("stringer_width")
    stringer_depth = dimensions.get("stringer_depth")

    # Extrude deck_profile and deck_outline out to calculate meeting point at top
    # of gunwale.
    profile_extruded = profile_deck.Shape.extrude(App.Vector(1, 0, 0) * 1000)
    plan_extruded = plan_deck.Shape.extrude(App.Vector(0, 0, 1) * 1000)
    gunwale_wire = profile_extruded.section(plan_extruded)

    gunwale_offset = gunwale_wire.copy().extrude(App.Vector(0, 0, 1) * -stringer_width)
    gunwale_solid = gunwale_offset.extrude(App.Vector(1, 0, 0) * -stringer_depth)
    self.stringers.append(gunwale_solid)

    gunwale_deep_wire = gunwale_wire.copy().translate(App.Vector(0, 0, 1) * stringer_width.Value)
    gunwale_deep_wire = gunwale_deep_wire.translate(App.Vector(1, 0, 0) * stringer_depth.Value)
    gunwale_deep_offset = gunwale_deep_wire.extrude(App.Vector(0, 0, 1) * -stringer_width.Value * 2)
    gunwale_deep_solid = gunwale_deep_offset.extrude(App.Vector(1, 0, 0) * -stringer_depth.Value * 2)
    self.stringers_deep.append(gunwale_deep_solid)
    #Part.show(gunwale_solid, "gunwale_solid")
    #Part.show(gunwale_deep_solid, "gunwale_deep_solid")

  def draw_rib(self, doc, rib_position: float, rib_index: int, rib_wire: Part.Wire):
    dimensions = doc.getObjectsByLabel("dimensions")[0]
    rib_width = dimensions.get("rib_width").Value
    rib_depth = dimensions.get("rib_depth").Value
    rib_thwart_depth = dimensions.get("rib_thwart_depth").Value
    brace_width = dimensions.get("brace_width").Value
    brace_width_narrow = dimensions.get("brace_width_narrow").Value
    rib_chamfer_radius = dimensions.get("rib_chamfer_radius")
    rib_chamfer_radius_narrow = dimensions.get("rib_chamfer_radius_narrow")
    rib_outside_relief = dimensions.get("rib_outside_relief")
    thwart_height = dimensions.get("thwart_height").Value
    low_thwart_height = dimensions.get("low_thwart_height").Value
    deck_width = dimensions.get("deck_width")
    deck_height = dimensions.get("deck_height")
    rib_type = dimensions.get(f"rib_type_{rib_index}")

    if rib_type == "thwart_narrow":
      brace_width = brace_width_narrow
      rib_chamfer_radius = rib_chamfer_radius_narrow

    print("New rib:", rib_position, rib_index, rib_type)

    if rib_wire.Length < 1:
      return
    if rib_type == "skip":
      return

    # Get shapes of intersections between stringer and rib.
    plane = Part.Plane(App.Vector(0, int(rib_position), 0), App.Vector(0, 1, 0))
    stringers_intersection = []
    for stringer_deep in sorted(self.stringers_deep, key=lambda stringer : stringer.distToShape(Part.Vertex(0, 0, 0)), reverse=True):
      stringers_intersection.append(stringer_deep.common(plane))
      #Part.show(stringers_intersection[-1], "stringer_intersection")

    # Work out which parts of rib outline are between stringers.
    rib_wire_vertexes = sorted(rib_wire.copy().OrderedVertexes, key=lambda vertex : vertex.distToShape(Part.Vertex(0, 0, 0)), reverse=True)
    top_outer = rib_wire_vertexes[0]
    bottom_center = rib_wire_vertexes[-1]
    deck = Part.makeLine(top_outer.Point, top_outer.Point - App.Vector(deck_width.Value, 0.0, 0.0))

    rib_wire_with_deck = rib_wire.copy()
    rib_wire_with_deck.add(deck)
    rib_parts = rib_wire_with_deck.common(stringers_intersection)

    # Calculate a new rib outline, curving parts between stringers away from hull's skin.
    previous = bottom_center.Point
    new_rib_parts = []
    # Iterate parts we want rib edge to go through, from lowest part to highest.
    for rib_part in sorted(rib_parts.Edges, key = lambda edge: edge.BoundBox.ZMin):
      #Part.show(rib_part, "rib_part")

      # Sort Vertexes from lowest to highest.
      vertexes = sorted(rib_part.Vertexes, key=lambda vertex: vertex.Point.z)

      if abs(vertexes[0].Point.z - vertexes[-1].Point.z) < 1e-3:
        # Line section is horizontal. Must be part of the deck so we are done.
        break

      if previous is None:
        # First time through.
        previous = vertexes[-1].Point
        new_rib_parts.append(rib_part)
        continue

      vertex = vertexes[0].Point
      if previous == vertex:
        # Sections are separate edges.
        previous = vertexes[-1].Point
        new_rib_parts.append(rib_part)
        continue

      # Curve ribs away from skin between stringers.
      diff = (vertex - previous).normalize() * rib_outside_relief
      cross = (diff / 2).cross(App.Vector(0, 1, 0))
      new = (previous + vertex) / 2 + cross
      arc = Part.Arc(previous, new, vertex).toShape()
      previous = vertexes[-1].Point
      new_rib_parts.append(arc)
      new_rib_parts.append(rib_part)
    outer_rib_wire = Part.Wire(new_rib_parts)
    #Part.show(outer_rib_wire, "outer_rib_wire")

    inner_rib_wire = rib_wire.makeOffset2D(-rib_depth, openResult = True, fill = False)
    boundary = Part.makeBox(inner_rib_wire.BoundBox.XLength, inner_rib_wire.BoundBox.YLength, inner_rib_wire.BoundBox.ZLength,
                            App.Vector(0, inner_rib_wire.BoundBox.YMin, inner_rib_wire.BoundBox.ZMin))
    section = inner_rib_wire.common(boundary)
    inner_rib_wire = section.Wires[0]

    outer_ends = get_wire_ends(outer_rib_wire)
    inner_ends = get_wire_ends(inner_rib_wire)

    bottom = Part.makeLine(outer_ends[0], inner_ends[-1])
    top = Part.makeLine(inner_ends[0], outer_ends[-1])
    inner_rib_wire.add(top)
    inner_rib_wire.add(bottom)
    rib_wire = Part.Wire([inner_rib_wire, outer_rib_wire], closed = True)
    #Part.show(rib_wire, "rib_wire")
    rib_face = Part.Face(rib_wire)


    if abs(rib_wire.BoundBox.XMax) > rib_depth * 2:
      # Big enough to fit thwarts in.
      if rib_type == "open":
        thwart_height = low_thwart_height

      rib_intersection_height = Part.makeLine(
          App.Vector(deck_width.Value, float(rib_position), thwart_height),
          App.Vector(0.0, float(rib_position), thwart_height)
      )
      rib_intersection_bottom = Part.makeLine(
          App.Vector(brace_width / 2, float(rib_position), thwart_height),
          App.Vector(brace_width / 2, float(rib_position), 0.0)
      )

      thwart_edge = None
      brace_edge = None

      best_thwart_edge_point = None
      for edge in rib_wire.Edges:
        common = DraftGeomUtils.findIntersection(rib_intersection_height, edge)
        point_center = App.Vector(0.0, float(rib_position), thwart_height)
        for point in common:
          if point != point_center and (best_thwart_edge_point is None or point.x < best_thwart_edge_point.x):
            # This is the point on the inside of the rib, not the outside, nearest the hull's outer skin.
            best_thwart_edge_point = point
            thwart_edge = Part.makeLine(point, point_center)

        common = DraftGeomUtils.findIntersection(rib_intersection_bottom, edge)
        point_center = App.Vector(brace_width / 2, float(rib_position), thwart_height)
        for point in common:
          if point != point_center:
            brace_edge = Part.makeLine(point, point_center)

      if thwart_edge:
        thwart_face = thwart_edge.extrude(App.Vector(0, 0, 1) * -rib_thwart_depth)
        rib_face = rib_face.fuse(thwart_face)

      if brace_edge:
        brace_face = brace_edge.extrude(App.Vector(1, 0, 0) * -brace_width / 2)
        rib_face = rib_face.fuse(brace_face)

      rib_face = DraftGeomUtils.concatenate(rib_face)
      if rib_type in ("thwart", "thwart_narrow"):
        rib_face = self.chamfer_rib_hole(rib_face, rib_chamfer_radius, deck_width)
    else:
      # Too small to do offset. Just make a solid rib.
      xmin = min(outer_rib_wire.OrderedVertexes[0].X, outer_rib_wire.OrderedVertexes[-1].X)
      zmin = min(outer_rib_wire.OrderedVertexes[0].Z, outer_rib_wire.OrderedVertexes[-1].Z)
      xmax = max(outer_rib_wire.OrderedVertexes[0].X, outer_rib_wire.OrderedVertexes[-1].X)
      zmax = max(outer_rib_wire.OrderedVertexes[0].Z, outer_rib_wire.OrderedVertexes[-1].Z)
      y = outer_rib_wire.OrderedVertexes[0].Y

      edge_top = Part.makeLine((xmax, y, zmax), (0, y, zmax))
      edge_center = Part.makeLine((0, y, zmax), (0, y, zmin))
      wire = Part.Wire([outer_rib_wire, edge_top, edge_center])
      rib_face = Part.Face(wire)

    rib_face = rib_face.common(self.hull)
    rib_face.translate(-App.Vector(0, 1, 0) * rib_width / 2)

    #to_cut = [solid for stringer in self.stringers_deep for solid in stringer.Solids]
    #rib_face = rib_face.cut(to_cut)
    # Interestingly it's quicker to cut these out one at a time rather than provide a list in a  single cut.
    for stringer_deep in self.stringers_deep:
      for solid in stringer_deep.Solids:
        rib_face = rib_face.cut(solid)
    rib_face = rib_face.cut(self.keelson).cut(self.stem).cut(self.stern)

    rib_solid = rib_face.extrude(App.Vector(0, 1, 0) * rib_width)

    self.ribs[rib_position] = rib_solid

    # set up the group to store the displayed ribs in later.
    group_component = create_group(doc, f"rib_{rib_position}")
    self.group.addObjects([group_component])
    self.rib_groups[rib_position] = group_component

  def chamfer_rib_hole(self, rib_face, rib_chamfer_radius, deck_width):
    inner_wire = sorted(rib_face.Wires, key=lambda value: value.Length)[0]
    # Remove too short edges.
    inner_wire = Part.Wire(list(filter(lambda edge: edge.Length > 1e-4, inner_wire.Edges)))

    outer_wire = sorted(rib_face.Wires, key=lambda value: value.Length)[-1]
    outer_face = Part.Face(outer_wire)

    try:
      offset = inner_wire.makeOffset2D(-rib_chamfer_radius, openResult = False, fill = False)
    except:
      inner_wire.reverse()
      try:
        offset = inner_wire.makeOffset2D(-rib_chamfer_radius, openResult = False, fill = False)
      except:
        print("WARN: Failed to fillet rib. Try reducing 'rib_chamfer_radius' value. A")
        return rib_face

    previous = offset.Edges[-1]
    for offset_edge in offset.Edges:
      if offset_edge.Vertexes[0].Point == previous.Vertexes[0].Point:
        common = offset_edge.Vertexes[0].Point
        other = (offset_edge.Vertexes[-1].Point, previous.Vertexes[-1].Point)
      elif offset_edge.Vertexes[0].Point == previous.Vertexes[-1].Point:
        common = offset_edge.Vertexes[0].Point
        other = (offset_edge.Vertexes[-1].Point, previous.Vertexes[0].Point)
      elif offset_edge.Vertexes[-1].Point == previous.Vertexes[0].Point:
        common = offset_edge.Vertexes[-1].Point
        other = (offset_edge.Vertexes[0].Point, previous.Vertexes[-1].Point)
      elif offset_edge.Vertexes[-1].Point == previous.Vertexes[-1].Point:
        common = offset_edge.Vertexes[-1].Point
        other = (offset_edge.Vertexes[0].Point, previous.Vertexes[0].Point)
      else:
        print("WARN: Failed to fillet rib. Try reducing 'rib_chamfer_radius' value. B")
        continue
      previous = offset_edge

      v1 = (common - other[0]).normalize()
      v2 = (common - other[1]).normalize()

      angle = math.acos(v1.dot(v2))
      #print(round(math.degrees(angle)))
      if angle > 3 * math.pi / 4:
        continue

      arc = Part.makeCircle(rib_chamfer_radius, common, App.Vector(0, 1, 0))
      arc_end_angles = []
      arc_end_vertex = []
      arc_end_edge = []
      for edge in inner_wire.Edges:
        dist, vec, infos = edge.distToShape(arc)
        if dist < 0.0001:
          angle = infos[0][5]
          arc_end_angles.append(math.degrees(angle))
          arc_end_vertex.append(vec[0][0])
          arc_end_edge.append(edge)

      if len(arc_end_angles) != 2:
        print(f"WARN: Unexpected number of intersections ({len(arc_end_angles)}) between arc and outline wire.")
        return rib_face

      angle_diff = arc_end_angles[0] - arc_end_angles[1]
      if angle_diff < 0:
        angle_diff += 360
      if angle_diff < 180:
        arc = Part.makeCircle(rib_chamfer_radius, common, App.Vector(0, 1, 0), arc_end_angles[1], arc_end_angles[0])
      else:
        arc = Part.makeCircle(rib_chamfer_radius, common, App.Vector(0, 1, 0), arc_end_angles[0], arc_end_angles[1])
      arc_offset = arc.makeOffset2D(-deck_width, openResult = True, fill = True)
      arc_offset = arc_offset.common(outer_face)  # Can probably do this once for all 3 arcs.
      #Part.show(arc_offset, "arc_offset")

      rib_face = rib_face.fuse(arc_offset)
    return rib_face

  def draw_stem(self):
    profile_keel = doc.getObjectsByLabel('profile_keel')[0]
    dimensions = doc.getObjectsByLabel("dimensions")[0]
    deck_length = dimensions.get("deck_length")
    prow_height = dimensions.get("prow_height")
    keelson_length = dimensions.get("keelson_length")
    stem_depth = dimensions.get("stem_depth")
    stem_overlap = dimensions.get("stem_overlap")
    rib_width = dimensions.get("rib_width")
    stem_length = (deck_length - keelson_length) / 2 + stem_overlap

    box = Part.makeBox(2, stem_length, prow_height, App.Vector(-1, -deck_length / 2, 0), App.Vector(0, 0, 1))
    section = box.common(profile_keel.Shape)
    section = section.translate(App.Vector(1, 0, 0) * -rib_width / 2)

    if get_wire_curvature(section.Wires[0]) > 0:
      section.reverse()

    offset = section.makeOffset2D(-stem_depth, openResult = True, fill = True)
    part_3d = offset.extrude(App.Vector(1, 0, 0) * rib_width)

    group_component = create_group(doc, f"stem")
    self.group.addObjects([group_component])
    group_component.addObjects([ Part.show(part_3d) ])
    self.stem = part_3d
    self.components_flat["stem"] = part_3d

  def draw_stern(self):
    profile_keel = doc.getObjectsByLabel('profile_keel')[0]
    dimensions = doc.getObjectsByLabel("dimensions")[0]
    deck_length = dimensions.get("deck_length")
    prow_height = dimensions.get("prow_height")
    keelson_length = dimensions.get("keelson_length")
    stem_overlap = dimensions.get("stem_overlap")
    stem_depth = dimensions.get("stem_depth")
    rib_width = dimensions.get("rib_width")
    stern_length = (deck_length - keelson_length) / 2 + stem_overlap

    box = Part.makeBox(2, stern_length, prow_height, App.Vector(-1, deck_length / 2 - stern_length, 0), App.Vector(0, 0, 1))
    section = box.common(profile_keel.Shape)
    section = section.translate(App.Vector(1, 0, 0) * -rib_width / 2)

    offset = section.makeOffset2D(-stem_depth, openResult = True, fill = True)
    part_3d = offset.extrude(App.Vector(1, 0, 0) * rib_width)

    group_component = create_group(doc, f"stern")
    self.group.addObjects([group_component])
    group_component.addObjects([ Part.show(part_3d) ])
    self.stern = part_3d
    self.components_flat["stern"] = part_3d

  def draw_keelson(self):
    profile_keel = doc.getObjectsByLabel('profile_keel')[0]
    dimensions = doc.getObjectsByLabel("dimensions")[0]
    prow_height = dimensions.get("prow_height")
    keelson_length = dimensions.get("keelson_length")
    keelson_width = dimensions.get("keelson_width")
    keelson_depth = dimensions.get("keelson_depth")
    accurate_stringers = dimensions.get("accurate_stringers")

    box = Part.makeBox(2, keelson_length, prow_height, App.Vector(-1, -keelson_length / 2, 0), App.Vector(0, 0, 1))
    section = box.common(profile_keel.Shape)
    section = section.translate(App.Vector(1, 0, 0) * -keelson_width / 2)

    offset = section.extrude(App.Vector(1, 0, 0) * keelson_width)
    part_3d = offset.extrude(App.Vector(0, 0, 1) * keelson_depth)

    part_3d = part_3d.common(self.hull)

    group_component = create_group(doc, f"keelson")
    self.group.addObjects([group_component])
    group_component.addObjects([ Part.show(part_3d) ])
    self.keelson = part_3d
    self.components_bulk["keelson"] = part_3d

  def mirror_sides(self):
    for rib_position, rib in self.ribs.items():
      rib_mirrored = rib.copy().mirror(App.Vector(0, 0, 0), App.Vector(1, 0, 0))
      rib = rib.fuse(rib_mirrored)
      rib = rib.removeSplitter()
      name = f"rib_{rib_position}"
      self.rib_groups[rib_position].addObjects([Part.show(rib, name)])
      self.components_flat[name] = rib

    for stringer in self.stringers:
      stringer_mirrored = stringer.copy().mirror(App.Vector(0, 0, 0), App.Vector(1, 0, 0))
      #stringer = stringer.fuse(stringer_mirrored)
      name = f"stringer_{round(stringer.BoundBox.YMin)}"
      name_port = f"{name}_port"
      name_starboard = f"{name}_starboard"
      self.stringers_group.addObjects([
        Part.show(stringer, name_port),
        Part.show(stringer_mirrored, name_starboard)])
      self.components_bulk[name_port] = stringer
      self.components_bulk[name_starboard] = stringer_mirrored

  @classmethod
  def diagonal_normal_at(cls, diagonal, point):
    for diagonal_edge in diagonal.Edges:
      plane = diagonal_edge.Curve.toShape().findPlane()
      if plane:
        return plane.Axis
    return None

  def draw_deck(self):
    dimensions = doc.getObjectsByLabel("dimensions")[0]
    thwart_height = dimensions.get("thwart_height")
    stringer_depth = dimensions.get("stringer_depth")
    deck_thickness = dimensions.get("deck_thickness")
    deck_width = dimensions.get("deck_width")
    rib_width = dimensions.get("rib_width")

    deck_section_indexes = [
        (0, 2),
        (3, 4),
        (6, 8)
        ]

    rib_positions = []
    index = 0
    while True:
      rib_pos_label = f"rib_positions_{index}"
      try:
        rib_position = dimensions.get(rib_pos_label)
      except ValueError:
        break
      rib_positions.append(rib_position)
      index += 1

    plane = Part.Plane(App.Vector(0, 0, thwart_height), App.Vector(0, 0, 1))
    deck_plan = self.hull.common(plane)

    outline = clean_wire(deck_plan)
    #Part.show(outline, "outline")
    offset = outline.makeOffset2D(-stringer_depth, openResult = False)
    #Part.show(offset, "offset")

    face = Part.Face(offset)
    full_deck = face.extrude(App.Vector(0, 0, deck_thickness))
    #Part.show(full_deck, "full_deck")

    group_component = create_group(doc, f"deck")
    self.group.addObjects([group_component])

    for index_start, index_end in deck_section_indexes:
      mask_len = rib_positions[index_end] - rib_positions[index_start] + rib_width.Value
      mask = Part.makeBox(deck_width, mask_len, deck_thickness * 2, App.Vector(-deck_width / 2, rib_positions[index_start] - rib_width.Value / 2, thwart_height))
      deck_part = mask.common(full_deck.copy())
      group_component.addObjects([ Part.show(deck_part, f"dec_section_{index_start}_{index_end}") ])
      self.components_flat[f"deck_{index_start}_{index_end}"] = deck_part


class Mass:
  def __init__(self, doc, components: Components):
    print(components.components_flat)
    print(components.components_bulk)

    self.doc = doc
    self.components = components

    dimensions = doc.getObjectsByLabel("dimensions")[0]
    plywood_density = dimensions.get("plywood_density")
    pine_density = dimensions.get("pine_density")

    flat_volume = self.get_volume(components.components_flat)
    bulk_volume = self.get_volume(components.components_bulk)

    flat_volume_m3 = round(flat_volume / 1e9, 5)
    bulk_volume_m3 = round(bulk_volume / 1e9, 5)
    print(
        f"pine:    {flat_volume_m3:4.3f}m³ {flat_volume_m3 * pine_density:4.2f}kg")
    print(
        f"plywood: {bulk_volume_m3:4.3f}m³ {bulk_volume_m3 * plywood_density:4.2f}kg")

  def get_volume(self, parts):
    total_volume = 0
    for label, component in parts.items():
      print(f"{label:<25}:{round(component.Volume / 1e9, 5)}m^3")
      total_volume += component.Volume
    return total_volume


class Layout:
  bodies = {}
  faces = []

  def __init__(self, doc, components: Components):
    self.doc = doc
    self.components = components
    self.cutouts = create_group(doc, "cutouts", type_ = 'App::Part')
    self.cutouts.Visibility = False
    self.scratch = create_group(self.doc, "scratch")
    self.scratch.Visibility = False
    self.plans = create_group(self.doc, "plans")

    self.project_parts()
    self.draw_plans()
    self.export_dxf()

  def project_parts(self):
    x_pos_offset = 1000
    y_pos_offset = -2000
    y_pos_mod = 0
    for label, component in self.components.components_flat.items():
      label = label.replace("-", "M")
      center = component.CenterOfGravity
      if "rib" in label:
        direction = App.Vector(1, 0, 0)
        x_pos = component.BoundBox.XLength / 2 + x_pos_offset
        y_pos = y_pos_offset
        y_pos_mod += component.BoundBox.ZLength + 50
        z_pos = -component.BoundBox.YMin
      elif label in ["stem", "stern"]:
        direction = App.Vector(0, 1, 0)
        x_pos = x_pos_offset
        y_pos = -component.BoundBox.YMax + y_pos_offset
        y_pos_mod += component.BoundBox.YLength + 50
        z_pos = -component.BoundBox.XMin

      body = doc.addObject('PartDesign::Body', f"cutout_{label}")
      self.cutouts.addObject(body)
      feature = App.ActiveDocument.addObject(
          "Part::Feature", f"cutout_feature_{label}")
      feature.Label = f"cutout_feature_{label}"
      self.cutouts.addObject(feature)
      feature.Shape = component
      body.BaseFeature = feature
      feature.ViewObject.Visibility = False

      y_pos += y_pos_mod
      body.Placement = App.Placement(App.Vector(x_pos, y_pos, z_pos), direction, 90)

      self.bodies[label] = body

  def draw_plans(self):
    for label, body in self.bodies.items():
      link = doc.addObject('App::Link', f"link_cutout_{label}")
      link.setLink(body)
      link.Label = f"link_cutout_{label}"
      link.LinkTransform = True
      link.ViewObject.Visibility = False
      self.scratch.addObject(link)

      face = Draft.make_shape2dview(link, App.Vector(0, 0, 1))
      face.Label = f"face_{label}"
      self.plans.addObject(face)
      self.faces.append(face)

  def export_dxf(self):
    dimensions = doc.getObjectsByLabel("dimensions")[0]
    export_dxf = dimensions.get("export_dxf")
    if not export_dxf:
      return

    path = u"/home/duncan/Working/freecad_small_boat_hull/dingy.dxf"
    self.doc.recompute()
    importDXF.export(self.faces, path, lwPoly=True)


def has_object_by_label(doc, label):
  return label in [o.Label for o in FreeCAD.ActiveDocument.Objects]


def remove_group(doc, name):
  if not has_object_by_label(doc, name):
    return

  groups = doc.getObjectsByLabel(name)
  if not isinstance(groups, list):
    groups = [groups]

  for group in groups:
    if group:
      try:
        OpenSCADUtils.removesubtree(group)
      except TypeError:
        group.removeObjectsFromDocument()
        doc.removeObject(group.Name)


def create_group(doc, name, type_ = 'App::DocumentObjectGroup'):
  remove_group(doc, name)
  return doc.addObject(type_, name)


def addSelection(doc, label):
  if not has_object_by_label(doc, label):
    return
  Gui.Selection.addSelection(doc.Name, label)


def get_body():
  selected_objects = Gui.Selection.getSelection()
  if len(selected_objects) != 1:
    return None

  selected_object = selected_objects[0]
  if selected_object.TypeId == "PartDesign::Body":
    if "__" in selected_object.Name:
      original_name = selected_object.Name.split("__plan_")[0]
      selected_object = doc.getObjectsByLabel(original_name)[0]
    return selected_object

  selected_object = selected_object.getParent()
  if selected_object.TypeId == "PartDesign::Body":
    if "__plan_" in selected_object.Name:
      original_name = selected_object.Name.split("__plan_")[0]
      selected_object = doc.getObjectsByLabel(original_name)[0]
    return selected_object

  return None

def perpendicular(wire, position):
  """
  Calculate angle perpendicular to wire.
  Args:
    wire: Part.Wire: A FreeCAD wire.
    position: App.Vector: Position on wire to calculate angle at.
  Returns:
    Tuple:
      Angle perpendicular to wire.
      Position on Z axis line at angle passing through input position crosses.
        Used for projecting slicing plane.
  """
  for edge in wire.OrderedEdges:
    shapes = edge.Curve.toBiArcs(1)
    for shape in shapes:
      distance = shape.projectPoint(position, "Distance")
      if len(distance) == 1 and distance[0] < 0.1:
        if isinstance(shape, Part.ArcOfCircle):
          vector = shape.Location - position
        elif isinstance(shape, Part.LineSegment):
          vector = (shape.EndPoint - shape.StartPoint).cross(App.Vector(0, 1, 0))
        else:
          print(shape)
          continue

        angle = vector.normalize().getAngle(App.Vector(0, 0, 1))
        print(angle, math.degrees(angle))
        angle += math.radians(10)

        z = position.z - position.x / math.tan(-angle)
        print(round(z, 2))

        #Part.show(Part.makeLine(position, App.Vector(0, 0, z)),  "line")
        #Part.show(Part.makeLine(position, position + vector.normalize() * 500), "line")

        return (angle, z)
  return None

def get_wire_ends(wire):
  """ Gets ends of a wire. Returns a list of any vertexes in a wire with only one connection. """
  end_points = []
  for vertex in wire.Vertexes:
      if len(wire.ancestorsOfType(vertex, Part.Edge)) == 1:
          end_points.append(vertex.Point)

  return end_points

def simplify_arcs(wire: Part.Wire) -> Part.Wire:
  """ Rewrite any Part::GeomOffsetCurve shapes as simple Arc and Lines."""
  modified_edges = []
  for edge in wire.Edges:
    if edge.Curve.TypeId == "Part::GeomOffsetCurve":
      for new in edge.Curve.toBSpline().toBiArcs(0.001):
        modified_edges.append(new.toShape())
    else:
      modified_edges.append(edge)
  modified_edges = Part.sortEdges(modified_edges)[0]
  return Part.Wire(modified_edges)

def get_wire_curvature(wire):
  ordered_vertexes = wire.OrderedVertexes
  a = ordered_vertexes[0].Point
  b = ordered_vertexes[int(len(ordered_vertexes) / 2)].Point
  c = ordered_vertexes[-1].Point
  curvature = (a -b).cross(b - c).z
  return curvature

def clean_wire(wire):
  """ Turn wire with Curves as edges into straight lines as edges. """
  # Join all curves into one.
  combined_curve = None
  for index, edge in enumerate(wire.Edges):
    if combined_curve is None:
      combined_curve = edge.Curve.copy()
    else:
      combined_curve.join(edge.Curve.copy())

  # Split curve into Vertexes and make lines from them.
  last_point = None
  edges = []
  for point in combined_curve.discretize(Angular=0.5, Curvature=0.1):
    if last_point is not None:
      edges.append(Part.LineSegment(last_point, point).toShape())
    last_point = point

  return Part.Wire(edges)

def clean_wire2(wire):
  edges = []
  start_point = None
  for index, edge in enumerate(wire.Edges):
    if start_point:
      edges.append(Part.LineSegment(start_point, edge.valueAt(edge.LastParameter)).toShape())
    start_point = edge.valueAt(edge.LastParameter)

  wire = Part.Wire(edges)
  return wire

doc = App.ActiveDocument
body = get_body()

start = time.perf_counter()
pr = cProfile.Profile()
pr.enable()

if body:
  data_x = Slice_Profile(doc, body, intersection_count = 5)
  View_Wireframe_Profile(body.Name, doc, body, data_x)

  data_y = Slice_Waterline(doc, body, intersection_count = 6)
  View_Wireframe_Waterline(body.Name, doc, body, data_y)

  data_z = Slice_CrossSection(doc, body)
  #data_z = Slice_CrossSection(doc, body, section_positions = [-1700, -1350, -900, -450, 0, 450, 900, 1350, 1700])
  #data_z = Slice_CrossSection(doc, body, intersection_count = 11)
  View_Wireframe_Body(body.Name, doc, body, data_z)

  data_xz = Slice_Diagonals(doc, body, data_z)
  #data_xz = Slice_Diagonals(doc, body, data_z, section_positions = [(70, 360), (59, 326.82), (48, 275.94), (35, 188.63)])
  #data_xz = Slice_Diagonals(doc, body, data_z, intersection_count = 5)
  View_Wireframe_Diagonals(body.Name, doc, body, data_xz)

  lowest_point = min(data_x.lowest_point, data_y.lowest_point)
  lowest_point = min(lowest_point, data_z.lowest_point)

  Plans(doc, body.Name, lowest_point)

  components = Components(doc, body.Name, body.Shape, data_xz)
  Layout(doc, components)
  Mass(doc, components)

else:
  print("No hull selected.")

Gui.Selection.clearSelection()
Gui.Selection.addSelection(doc.Name, body.Name)

pr.disable()
pr.dump_stats("profile.cprof")
end = time.perf_counter()
print(f"Took {end - start} seconds")
