# vim: set ft=python :
# vim: set expandtab :

import math
import time
import cProfile

import Draft
import FreeCADGui
import OpenSCADUtils
import TechDraw
import Part
import DraftGeomUtils
from FreeCAD import Units

class Slice_Base(list):
  intersection_count: int
  plane = App.Vector(0, 0, 0)
  lowest_point = 0
  section_positions = []

  def __init__(self, doc, hull_body, intersection_count = 12, section_positions = []):
    self.doc = doc
    self.hull_body = hull_body
    self.intersection_count = intersection_count
    self.section_positions = section_positions
    bound_box = self.hull_body.Shape.BoundBox
    self.lowest_point = bound_box.ZMin

    self.slice()

  def _setup_section_positions(self):
    bound_box = self.hull_body.Shape.BoundBox

    self.slice_start = bound_box.ZMin
    slice_range = bound_box.ZLength
    self.slice_width = slice_range / (self.intersection_count + 1)

  def slice(self):

    if not self.section_positions:
      self._setup_section_positions()

      self.section_positions = [
            self.slice_start + (i * self.slice_width) + 0.1
            for i in range(self.intersection_count + 1)
          ]

    slices = self.hull_body.Shape.slices(self.plane, self.section_positions)
    print(f"{len(slices.Wires)} sections drawn for the {self.plane} axis")
    for slice in slices.Wires:
      self += self.slice_to_edges(slice)

  def slice_to_edges(self, slice):
    all_edges = []
    for edge in slice.Edges:
      candiate = self.filter_edge(edge)
      if candiate:
        all_edges.append(candiate)

    wires = []
    for wire in Part.sortEdges(all_edges):
      wires.append(Part.Wire(wire))
    return wires

  @classmethod
  def filter_edge(cls, edge):
    start_point = edge.firstVertex()
    end_point = edge.lastVertex()

    if start_point.X < -0.0001 or end_point.X < -0.0001:
      return None

    return edge

  def longest_element(self):
    longest = None
    for wire in self:
      if longest is None or wire.Length > longest.Length:
        longest = wire

    return longest


class Slice_CrossSection(Slice_Base):
  plane = App.Vector(0, 1, 0)

  def _setup_section_positions(self):
    bound_box = self.hull_body.Shape.BoundBox

    self.slice_start = bound_box.YMin
    slice_range = bound_box.YLength
    self.slice_width = slice_range / (self.intersection_count + 1)

  def _setup_section_positions(self):
    bound_box = self.hull_body.Shape.BoundBox

    if not self.section_positions:
      slice_range = bound_box.YLength
      slice_width = slice_range / (self.intersection_count + 1)
      slice_end = bound_box.YMax - slice_width / 4

      self.slice_start = bound_box.YMin + slice_width / 4 + 1
      self.slice_width = abs(self.slice_start - slice_end) / (self.intersection_count - 1)


class Slice_Waterline(Slice_Base):
  plane = App.Vector(0, 0, 1)

  def _setup_section_positions(self):
    bound_box = self.hull_body.Shape.BoundBox

    self.slice_start = bound_box.ZMin
    slice_range = bound_box.ZLength
    self.slice_width = slice_range / (self.intersection_count + 1)



class Slice_Profile(Slice_Base):
  plane = App.Vector(1, 0, 0)
  
  def _setup_section_positions(self):
    bound_box = self.hull_body.Shape.BoundBox

    self.slice_start = bound_box.XMin
    slice_range = bound_box.XLength
    self.slice_width = slice_range / (self.intersection_count + 1)



class Slice_Diagonals(Slice_Base):
  plane = App.Vector(1, 0, 1)

  def __init__(self, doc, hull_body, ribs: Slice_CrossSection, intersection_count = 6):
    self.ribs = ribs
    super().__init__(doc, hull_body, intersection_count)

  def slice(self):
    """
    The Diagonals don't follow the same pattern as the other perspectives.
    The plane changes angle with each slice.
    """
    slice_angle_step = math.radians(90.0 / self.intersection_count / 1.8)

    angle = math.radians(90) - slice_angle_step

    for _, position in self.iterate_longest_rib():
      if angle <= 0:
        break

      dist = position.z - position.x / math.tan(-angle)

      print(f"Calculating diagonal. angle: {round(math.degrees(angle), 2)}  height: {round(dist, 2)}")

      plane = App.Vector(math.cos(angle), 0, math.sin(angle))
      slices = self.hull_body.Shape.slice(plane, math.sin(angle) * dist)
      if not slices:
        continue

      for slice in slices:
        wires = self.slice_to_edges(slice)
        if len(wires) > 1:
          longest = None
          for wire in wires:
            if longest is None or wire.Length > longest.Length:
              longest = wire
          wires = [longest]
        self += wires

      angle -= slice_angle_step

  def iterate_longest_rib(self):
    rib = self.ribs.longest_element()
    #Part.show(rib, "rib")
    part_length = rib.Length / self.intersection_count
    rib_parts = rib.discretize(Distance = part_length)
    distance = 0
    for index, position in enumerate(rib_parts):
      yield (rib, position)
      distance += part_length


  @classmethod
  def filter_edge(cls, edge):
    # Filter edges ending when crossing over to other side of hull.
    start_point = edge.firstVertex()
    end_point = edge.lastVertex()
    if start_point.X < 0.0001 and end_point.X < 0.0001:
      return None

    # Filter intersections with deck.
    sketch = doc.getObjectsByLabel('profile_deck')[0]
    for sketch_edge in sketch.Shape.Edges:
      for point in edge.Vertexes:
        point = point.Point
        point.x = 0
        point = Part.Vertex(point)
        common = point.common([sketch_edge])
        if common.Vertexes:
          return None

    #Part.show(edge)
    return edge


class View_Wireframe_Base:
  """
  Base class to display wireframe of hull.
  """
  name: str = "base_class"

  def __init__(self, parent_name: str, doc, hull_body, data: Slice_Base):
    self.name = f"{parent_name}__{self.plan_name}"
    self.wireframe_name = f"{parent_name}__{self.wireframe_name}"
    self.doc = doc
    self.hull_body = hull_body
    self.data = data

    self.create_blank_sketch()

    for slice_index, slice in enumerate(self.data):
      self.parse_slice(slice, slice_index)

    for shape in self.wireframe.OutList:
      FreeCADGui.getDocument(self.doc.Name).getObject(shape.Name).LineColor = self.colour
      FreeCADGui.getDocument(self.doc.Name).getObject(shape.Name).PointColor = self.colour

  def create_blank_sketch(self):
    self.wireframe = create_group(self.doc, self.wireframe_name)

  def parse_slice(self, slice, slice_index):
    if not slice:
      return
    new_object = Part.show(slice)
    self.wireframe.addObjects([new_object])


class View_Wireframe_Body(View_Wireframe_Base):
  plan_name = "plan_body"
  wireframe_name = "wireframe_body"
  plan_offset = App.Vector(+2000.0, 0.0, 0.0)
  colour_fore = (255, 0, 0)
  colour_aft = (255, 255, 0)
  colour = (255, 0, 0)

  def __init__(self, parent_name: str, doc, hull_body, data: Slice_Base):
    super().__init__(parent_name, doc, hull_body, data)

    for shape in self.wireframe_fore.OutList:
      FreeCADGui.getDocument(self.doc.Name).getObject(shape.Name).LineColor = self.colour_fore
      FreeCADGui.getDocument(self.doc.Name).getObject(shape.Name).PointColor = self.colour_fore

    for shape in self.wireframe_aft.OutList:
      FreeCADGui.getDocument(self.doc.Name).getObject(shape.Name).LineColor = self.colour_aft
      FreeCADGui.getDocument(self.doc.Name).getObject(shape.Name).PointColor = self.colour_aft


  def create_blank_sketch(self):
    self.wireframe_fore = create_group(self.doc, f"{self.wireframe_name}_fore")
    self.wireframe_aft = create_group(self.doc, f"{self.wireframe_name}_aft")
    self.wireframe = self.wireframe_fore

  def parse_slice(self, slice, slice_index):
    if slice_index > len(self.data) / 2:
      self.wireframe = self.wireframe_fore
      self.colour = self.colour_fore
    else:
      self.wireframe = self.wireframe_aft
      self.colour = self.colour_aft

    super().parse_slice(slice, slice_index)


class View_Wireframe_Waterline(View_Wireframe_Base):
  plan_name = "plan_waterline"
  wireframe_name = "wireframe_waterline"
  plan_offset = App.Vector(+4000.0, 0.0, 0.0)
  colour = (0, 255, 0)


class View_Wireframe_Profile(View_Wireframe_Base):
  plan_name = "plan_profile"
  wireframe_name = "wireframe_profile"
  plan_offset = App.Vector(+6000.0, 0.0, 0.0)
  colour = (0, 0, 255)


class View_Wireframe_Diagonals(View_Wireframe_Base):
  plan_name = "plan_diagonal"
  wireframe_name = "wireframe_diagonal"
  plan_offset = App.Vector(+8000.0, 0.0, 0.0)
  colour = (200, 200, 200)


class Plans:
  def __init__(self, doc, parent_name: str, lowest_point: float):
    self.doc = doc
    self.lowest_point = lowest_point

    group_profile = create_group(doc, f"{parent_name}__plan_profile")
    group_body = create_group(doc, f"{parent_name}__plan_body")
    group_waterline = create_group(doc, f"{parent_name}__plan_waterline")

    offset_plan_profile = 1000
    offset_plan_body = 2000
    offset_plan_waterline = 3500

    for shape in self.doc.getObjectsByLabel(f"{parent_name}__wireframe_profile"):
      self.draw_line(shape.Shape, App.Vector(1, 0, 0), offset_plan_profile, group_profile, True, False)
      self.draw_line(shape.Shape, App.Vector(0, 1, 0), offset_plan_body, group_body, False, False)
      self.draw_line(shape.Shape, App.Vector(0, 1, 0), offset_plan_body, group_body, False, True)
      self.draw_line(shape.Shape, App.Vector(0, 0, 1), offset_plan_waterline, group_waterline, False, False)
      self.draw_line(shape.Shape, App.Vector(0, 0, 1), offset_plan_waterline, group_waterline, False, True)

    for shape in self.doc.getObjectsByLabel(f"{parent_name}__wireframe_body_fore"):
      self.draw_line(shape.Shape, App.Vector(1, 0, 0), offset_plan_profile, group_profile, False, False)
      self.draw_line(shape.Shape, App.Vector(0, 1, 0), offset_plan_body, group_body, True, False)
      self.draw_line(shape.Shape, App.Vector(0, 0, 1), offset_plan_waterline, group_waterline, False, False)
      self.draw_line(shape.Shape, App.Vector(0, 0, 1), offset_plan_waterline, group_waterline, False, True)

    for shape in self.doc.getObjectsByLabel(f"{parent_name}__wireframe_body_aft"):
      self.draw_line(shape.Shape, App.Vector(1, 0, 0), offset_plan_profile, group_profile, False, False)
      self.draw_line(shape.Shape, App.Vector(0, 1, 0), offset_plan_body, group_body, True, True)
      self.draw_line(shape.Shape, App.Vector(0, 0, 1), offset_plan_waterline, group_waterline, False, False)
      self.draw_line(shape.Shape, App.Vector(0, 0, 1), offset_plan_waterline, group_waterline, False, True)

    for shape in self.doc.getObjectsByLabel(f"{parent_name}__wireframe_waterline"):
      self.draw_line(shape.Shape, App.Vector(1, 0, 0), offset_plan_profile, group_profile, False, False)
      self.draw_line(shape.Shape, App.Vector(0, 1, 0), offset_plan_body, group_body, False, False)
      self.draw_line(shape.Shape, App.Vector(0, 1, 0), offset_plan_body, group_body, False, True)
      self.draw_line(shape.Shape, App.Vector(0, 0, 1), offset_plan_waterline, group_waterline, True, False)

    for shape in self.doc.getObjectsByLabel(f"{parent_name}__wireframe_diagonal"):
      self.draw_line(shape.Shape, App.Vector(0, 0, 1), offset_plan_waterline, group_waterline, True, True)
      self.draw_line(shape.Shape, App.Vector(0, 1, 0), offset_plan_body, group_body, False, False)
      self.draw_line(shape.Shape, App.Vector(0, 1, 0), offset_plan_body, group_body, False, True)


  def draw_line(self, shape, direction, x_pos, group, foreground: bool, mirror: bool):
    outline, _, _, _ = TechDraw.project(shape, direction)
    new = Part.show(outline, "outline")

    if direction == App.Vector(1, 0, 0):
      new.Placement = App.Placement(
          App.Vector(x_pos - self.lowest_point, 0, self.lowest_point),
          App.Vector(1, 0, 0), 180)

    if mirror:
      if direction == App.Vector(0, 1, 0):
        new.Placement = App.Placement(
            App.Vector(x_pos - self.lowest_point, 0, self.lowest_point),
            App.Vector(1, 0, 0), 180)
      elif direction == App.Vector(0, 0, 1):
        new.Placement = App.Placement(
            App.Vector(x_pos, 0, self.lowest_point),
            App.Vector(0, 1, 0), 180)
    else:
      if direction == App.Vector(0, 1, 0):
        new.Placement = App.Placement(
            App.Vector(x_pos - self.lowest_point, 0, self.lowest_point),
            App.Vector(1, 0, 0), 0)
      elif direction == App.Vector(0, 0, 1):
        new.Placement = App.Placement(
            App.Vector(x_pos, 0, self.lowest_point),
            App.Vector(0, 1, 0), 0)

    if foreground:
      FreeCADGui.getDocument(self.doc.Name).getObject(new.Name).LineWidth = 2
      FreeCADGui.getDocument(self.doc.Name).getObject(new.Name).PointSize = 2
    else:
      FreeCADGui.getDocument(self.doc.Name).getObject(new.Name).LineWidth = 1
      FreeCADGui.getDocument(self.doc.Name).getObject(new.Name).PointSize = 1

    group.addObjects([new])


class Components:
  def __init__(self, doc, parent_name: str):
    self.doc = doc
    group_components = create_group(doc, f"{parent_name}__components")
    all_ribs = {}
    rib_diagonal_intersections = {}

    for shapes in self.doc.getObjectsByLabel(f"{parent_name}__wireframe_body_fore"):
      for shape in shapes.OutList:
        self.index_ribs(shape.Shape, all_ribs)

    for shapes in self.doc.getObjectsByLabel(f"{parent_name}__wireframe_body_aft"):
      for shape in shapes.OutList:
        self.index_ribs(shape.Shape, all_ribs)

    for rib in all_ribs.values():
      per_rib = []
      for rib_part in rib:
        for diagonals in self.doc.getObjectsByLabel(f"{parent_name}__wireframe_diagonal"):
          for diagonal in diagonals.OutList:
            dist, vectors, _ = diagonal.Shape.distToShape(rib_part)
            if dist < 0.01:
              per_rib.append((vectors[0][0], diagonal.Shape))
              continue
      if per_rib:
        y_pos = str(round(per_rib[0][0].y)).replace("-", "m")
        rib_diagonal_intersections[y_pos] = per_rib
      
    for y_pos in all_ribs:
      self.shape_rib(doc, y_pos, all_ribs[y_pos], rib_diagonal_intersections[y_pos], group_components)

  def index_ribs(self, shape, all_ribs):
    y_pos = str(round(shape.BoundBox.YMin)).replace("-", "m")
    if y_pos not in all_ribs:
      all_ribs[y_pos] = []

    all_ribs[y_pos].append(shape)

  def shape_rib(self, doc, rib_index, rib_shapes, diagonal_intersections, group):
    dimensions = doc.getObjectsByLabel("dimensions")[0]
    stringer_width = dimensions.get("stringer_width")
    stringer_depth = dimensions.get("stringer_depth")

    new_shapes = []
    intersections = []
    lowest_point = None
    highest_point = None
    for edge in rib_shapes[0].Edges:
      if lowest_point is None or edge.Vertexes[0].Point.z < lowest_point.z:
        lowest_point = edge.Vertexes[0].Point
      if lowest_point is None or edge.Vertexes[-1].Point.z < lowest_point.z:
        lowest_point = edge.Vertexes[-1].Point

      if highest_point is None or edge.Vertexes[0].Point.z > highest_point.z:
        highest_point = edge.Vertexes[0].Point  
        parameter = edge.Curve.parameter(highest_point)
        highest_rib_vector_at_intersection = edge.Curve.tangent(parameter)[0]
      if highest_point is None or edge.Vertexes[-1].Point.z > highest_point.z:
        highest_point = edge.Vertexes[-1].Point
        parameter = edge.Curve.parameter(highest_point)
        highest_rib_vector_at_intersection = edge.Curve.tangent(parameter)[0]

      for intersection, diagonal in diagonal_intersections:
        edge_parameter = edge.Curve.parameter(intersection)
        if edge_parameter > 0.0 and edge_parameter < 1.0:
          diagonal_vector_at_intersection = self.diagonal_normal_at(diagonal, intersection)

          rib_vector_at_intersection = edge.Curve.tangent(edge_parameter)[0]
          intersections.append((intersection, rib_vector_at_intersection, diagonal_vector_at_intersection))

    intersections.append((lowest_point, App.Vector(1, 0, 0), App.Vector(1, 0, 0)))
    intersections.append((highest_point, highest_rib_vector_at_intersection, highest_rib_vector_at_intersection))

    intersections.sort(key = lambda pair: pair[0].z)

    last_outer_top = None

    for intersection, rib_vector_at_intersection, diagonal_vector_at_intersection in intersections:
      projection = diagonal_vector_at_intersection.cross(App.Vector(0, 1, 0)) * stringer_depth
      outer_mid = intersection
      #outer_top = intersection + diagonal_vector_at_intersection * stringer_width / 2
      outer_top = intersection + rib_vector_at_intersection * stringer_width / 2
      outer_bottom = intersection - rib_vector_at_intersection * stringer_width / 2
      inner_top = intersection + diagonal_vector_at_intersection * stringer_width / 2 + projection
      inner_bottom = intersection - diagonal_vector_at_intersection * stringer_width / 2 + projection

      line = Part.makeLine(outer_top, inner_top)
      new_shapes.append(Part.show(line, "top"))

      line = Part.makeLine(outer_bottom, inner_bottom)
      new_shapes.append(Part.show(line, "bottom"))

      line = Part.makeLine(inner_top, inner_bottom)
      new_shapes.append(Part.show(line, "projected"))

      if last_outer_top is not None:
        line = Part.makeLine(last_outer_top, outer_bottom)
        new_shapes.append(Part.show(line, "join"))

      last_outer_top = outer_top

    group_component = create_group(doc, f"component_{rib_index}")
    group_component.addObjects(new_shapes)
    group.addObjects([group_component])

  @classmethod
  def diagonal_normal_at(cls, diagonal, point):
    for diagonal_edge in diagonal.Edges:
      return diagonal_edge.Curve.toShape().findPlane().Axis
    return None

  def add_rib(self, group_components, shape, all_ribs):
    y_pos = str(round(shape.BoundBox.YMin)).replace("-", "m")

    new_shapes = []

    new_wire = Part.Wire([shape.copy(), shape.copy().mirror(App.Vector(0, 0, 0), App.Vector(1, 0, 0))])
    new_shapes.append(Part.show(new_wire))

    try:
      offset = new_wire.makeOffset2D(-50, openResult = True, fill = True)
      new_shapes.append(Part.show(offset))
    except:
      pass

    if y_pos not in all_ribs:
      all_ribs[y_pos] = []
    all_ribs[y_pos] += new_shapes

    part = create_group(doc, f"component_{y_pos}")
    part.addObjects(new_shapes)
    group_components.addObjects([part])


def create_group(doc, name):
  print(f"Checking for: {name}")
  group = doc.getObjectsByLabel(name)
  if group:
    print(f"Removing previous sketch: {name}")
    OpenSCADUtils.removesubtree(group)

  return doc.addObject('App::DocumentObjectGroup', name)

def get_body():
  selected_objects = Gui.Selection.getSelection()
  if len(selected_objects) != 1:
    return None

  selected_object = selected_objects[0]
  if selected_object.TypeId == "PartDesign::Body":
    if "__plan_" in selected_object.Name:
      original_name = selected_object.Name.split("__plan_")[0]
      selected_object = doc.getObjectsByLabel(original_name)[0]
    return selected_object

  selected_object = selected_object.getParent()
  if selected_object.TypeId == "PartDesign::Body":
    if "__plan_" in selected_object.Name:
      original_name = selected_object.Name.split("__plan_")[0]
      selected_object = doc.getObjectsByLabel(original_name)[0]
    return selected_object

  return None

def perpendicular(wire, position):
  """
  Calculate angle perpendicular to wire.
  Args:
    wire: Part.Wire: A FreeCAD wire.
    position: App.Vector: Position on wire to calculate angle at.
  Returns:
    Tuple:
      Angle perpendicular to wire.
      Position on Z axis line at angle passing through input position crosses.
        Used for projecting slicing plane.
  """
  for edge in wire.OrderedEdges:
    shapes = edge.Curve.toBiArcs(1)
    for shape in shapes:
      distance = shape.projectPoint(position, "Distance")
      if len(distance) == 1 and distance[0] < 0.1:
        if isinstance(shape, Part.ArcOfCircle):
          vector = shape.Location - position
        elif isinstance(shape, Part.LineSegment):
          vector = (shape.EndPoint - shape.StartPoint).cross(App.Vector(0, 1, 0))
        else:
          print(shape)
          continue

        angle = vector.normalize().getAngle(App.Vector(0, 0, 1))
        print(angle, math.degrees(angle))
        angle += math.radians(10)

        z = position.z - position.x / math.tan(-angle)
        print(round(z, 2))

        #Part.show(Part.makeLine(position, App.Vector(0, 0, z)),  "line")
        #Part.show(Part.makeLine(position, position + vector.normalize() * 500),  "line")

        return (angle, z)
  return None


doc = App.ActiveDocument
body = get_body()

start = time.perf_counter()
pr = cProfile.Profile()
pr.enable()

if body:
  data_x = Slice_Profile(doc, body, intersection_count = 5)
  View_Wireframe_Profile(body.Name, doc, body, data_x)

  data_y = Slice_Waterline(doc, body, intersection_count = 6)
  View_Wireframe_Waterline(body.Name, doc, body, data_y)

  data_z = Slice_CrossSection(doc, body, intersection_count = 11, section_positions = [-1750, -1350, -900, -450, 0, 450, 900, 1350, 1750])
  #data_z = Slice_CrossSection(doc, body, intersection_count = 11)
  View_Wireframe_Body(body.Name, doc, body, data_z)

  data_xz = Slice_Diagonals(doc, body, data_z, intersection_count = 5)
  View_Wireframe_Diagonals(body.Name, doc, body, data_xz)

  lowest_point = min(data_x.lowest_point, data_y.lowest_point)
  lowest_point = min(lowest_point, data_z.lowest_point)

  Plans(doc, body.Name, lowest_point)

  Components(doc, body.Name)  

else:
  print("No hull selected.")

pr.disable()
pr.dump_stats("profile.cprof")
end = time.perf_counter()
print(f"Took {end - start} seconds")

